import os
import logging
from collections import OrderedDict
import sys

# Global constants
DEFAULT_DOT_EXTS_LOWER = ['.py', '.cpp', '.h', '.hpp', '.lua', '.cs', 
                          '.c', '.md', '.txt', '.rst', '.twig', '.js', 
                          '.htm', '.html', '.php']

# Skip directories generated by package managers
SKIP_DIRS = ['node_modules', 'vendor', 'composer', 'bin', 'obj']

# Default mappings of old to new repository names
DEFAULT_MIGRATIONS = OrderedDict()
DEFAULT_MIGRATIONS['Poikilos'] = ['poikilos']
DEFAULT_MIGRATIONS['Hierosoft'] = ['poikilos', 'expertmm']
DEFAULT_MIGRATIONS['LibreCSG'] = ['poikilos', 'Poikilos', 'expertmm']
DEFAULT_MIGRATIONS['samurai-ide'] = ['poikilos', 'Poikilos', 'Hierosoft']


class ReposState:
    """Manage multiple repos at a time. See also RepoState."""
    
    def __init__(self):
        self.new_owners = {}
        self.name_changes = {
            'EnlivenMinetest': ['ENLIVEN'],
        }
        self.migrations = DEFAULT_MIGRATIONS
        self.dot_exts = DEFAULT_DOT_EXTS_LOWER
        self.recommended_actions = None
        self.remote_repo_count = None
        self.local_repo_count = None
        self.actual_repos = OrderedDict()
        self.repo_depth = 0

    def check_everything(self, migrations):
        """Check all repositories based on migration data."""
        self.actual_repos = OrderedDict()
        old_orgs = OrderedDict()
        self.remote_repo_count = 0
        self.local_repo_count = 0
        self.recommended_actions = []

        for new_org in migrations.keys():
            # Fetch repos from GitHub API
            # For example: https://api.github.com/orgs/{new_org}/repos
            # Here, a placeholder for calling the API and parsing the JSON response
            repos = self.fetch_repos_from_github(new_org)
            self.actual_repos[new_org] = repos
            for repo in repos:
                self.new_owners[repo] = new_org
                self.remote_repo_count += 1

        # After remote repos are fetched, check local files
        self.check_files_here(os.path.abspath("."))

    def fetch_repos_from_github(self, org_name):
        """Placeholder function for GitHub API integration."""
        # Here you would use requests or another HTTP library to fetch the repos.
        # Returning a static list for illustration purposes.
        return ['repo1', 'repo2', 'repo3']

    def check_files_here(self, parent, depth=0):
        """Check all files in the parent directory recursively for URL fixes."""
        for sub in os.listdir(parent):
            path = os.path.join(parent, sub)

            if depth == 0:
                self.local_repo_count += 1

            # Skip files with non-target extensions
            if os.path.splitext(sub)[1].lower() not in self.dot_exts:
                continue

			# Check if the directory is a valid Git repository
			if depth == self.repo_depth and not os.path.isdir(os.path.join(path, ".git")):
				logger.warning(f"# {path} is not a git repo")
				continue

            if os.path.isdir(path) and sub not in SKIP_DIRS:
                self.check_files_here(path, depth=depth+1)
                continue

            if not os.path.isfile(path):
                logging.warning(f"Neither a file nor a directory: {path}")
                continue

            # Open file and check for old URLs
            with open(path, 'rb') as file:
                for line in file:
                    for old_org in DEFAULT_MIGRATIONS.values():
                        for repo in old_org:
                            new_owner = self.new_owners.get(repo, "[new owner]")
                            new_url = f"git@github.com:{new_owner}/{repo}.git".encode('utf-8')
                            old_url = f"https://github.com/{repo}/{repo}.git".encode('utf-8')

                            if old_url in line:
                                action = f'sed -i "s|{old_url.decode()}|{new_url.decode()}|g" "{path}"'
                                self.recommended_actions.append(action)

def main():
    """Main function to execute the repository check and provide recommended actions."""
    state = ReposState()
    state.check_everything(DEFAULT_MIGRATIONS)

    if state.recommended_actions:
        print("# Recommended actions:")
        for action in state.recommended_actions:
            print(action)
    else:
        print("# No recommended actions")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
